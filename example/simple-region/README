
This example shows how to use KGEN to extract a kernel from a simple Fortran application.
This example use KGEN directive to specify the region of kernel extraction.

[ Prerequisites ]
	1. Python Version >= 2.7
	2. cpp or fpp preprocessor
	3. make
	3. strace

[ Kernel extraction steps ]

	1. >> vi src/Makefile; # Modify FC if required

	2. >> make; # extract a kernel

	Once "make" is completed with success, you will see information similar to next lines on screen

		../../bin/kgen \
			-D ROW=4,COL=4 \
			-I ${KGENHOME}/example/simple-region/src \
			--timing repeat=1000 \
			--invocation 0:0:1,0:0:2,0:0:3 \
			--kernel-compile FC="'gfortran'" \
			--state-build cmds="cd ${KGENHOME}/example/simple-region/src; make build FC='gfortran'" \
			--state-run cmds="cd ${KGENHOME}/example/simple-region/src; make run" \
			--check tolerance=1.0D-10 \
			${KGENHOME}/example/simple-region/src/update_mod.F90

		Pre-processing is done
		Reading ${KGENHOME}/example/simple/src/update_mod.F90
		Reading ${KGENHOME}/example/simple/src/calc_mod.F90
			in the search of "calc" directly from update_mod.F90 and originally from update_mod.F90
		Program is analyzed
		Makefiles are generated
		Post-processing is done
		Completed.

	After this step, two subfolders(kernel and state) will be created under this folder.

	3. >> cd state; # move to a directory for instrumentation files

	4. >> make; # generate state data files

	In this step, original application will be built/run again with instrumented files in state folder

	Once "make" is completed with success, you will see information similar to next lines on screen

		if [ ! -f ${KGENHOME}/example/simple/src/update_mod.F90.kgen_org ]; then cp -f ${KGENHOME}/example/simple/src/update_mod.F90 ${KGENHOME}/example/simple/src/update_mod.F90.kgen_org; fi
		if [ ! -f update_mod.F90.kgen_org ]; then cp -f ${KGENHOME}/example/simple/src/update_mod.F90 update_mod.F90.kgen_org; fi
		#rm -f kernel.exe *.mod *.o
		cp -f update_mod.F90 ${KGENHOME}/example/simple/src/update_mod.F90
		cd ${KGENHOME}/example/simple/src; make build
		make[1]: Entering directory `${KGENHOME}/example/simple/src'
		gfortran -c -o calc_mod.o calc_mod.F90
		gfortran -DROW=4 -DCOL=4 -c -o update_mod.o update_mod.F90
		gfortran -c -o program.o program.F90
		gfortran -o demo.exe program.o update_mod.o calc_mod.o
		make[1]: Leaving directory `${KGENHOME}/example/simple/src'
		mv -f ${KGENHOME}/example/simple/src/update_mod.F90.kgen_org ${KGENHOME}/example/simple/src/update_mod.F90
		cd ${KGENHOME}/example/simple/src; make run
		make[1]: Entering directory `${KGENHOME}/example/simple/src'
		./demo.exe
		 Collected Kernel Input/Ouput state from:            0           0           1
		 Collected Kernel Input/Ouput state from:            0           0           2
		 Collected Kernel Input/Ouput state from:            0           0           3
		 Stopping application...
		0
		make[1]: Leaving directory `${KGENHOME}/example/simple/src'

	5. >> cd ../kernel; # move to a kernel directory

	6. >> make; # build and run a kernel

	In this step, the generated kernel will be built/run and verfication and timing information will be displayed on screen.

		true; 'gfortran'  -c -o kgen_utils.o kgen_utils.f90
		true; 'gfortran'  -c -o calc_mod.o calc_mod.F90
		true; 'gfortran'  -c -o update_mod.o update_mod.F90
		true; 'gfortran'  -c -o kernel_driver.o kernel_driver.f90
		true; 'gfortran'    -o kernel.exe update_mod.o calc_mod.o kernel_driver.o kgen_utils.o
		true; ./kernel.exe
		 
		 ***************** Verification against 'calc.0.0.1' *****************
		 
		 Number of verified variables:            3
		 Number of identical variables:            3
		 Number of non-identical variables within tolerance:            0
		 Number of non-identical variables out of tolerance:            0
		 Tolerance:    1.0000000000000000E-010
		 
		 Verification PASSED
		 
		 calc : Time per call (usec):    8.4717005491256714E-002
		 
		 ***************** Verification against 'calc.0.0.2' *****************
		 
		 Number of verified variables:            3
		 Number of identical variables:            3
		 Number of non-identical variables within tolerance:            0
		 Number of non-identical variables out of tolerance:            0
		 Tolerance:    1.0000000000000000E-010
		 
		 Verification PASSED
		 
		 calc : Time per call (usec):    8.4090001881122589E-002
		 
		 ***************** Verification against 'calc.0.0.3' *****************
		 
		 Number of verified variables:            3
		 Number of identical variables:            3
		 Number of non-identical variables within tolerance:            0
		 Number of non-identical variables out of tolerance:            0
		 Tolerance:    1.0000000000000000E-010
		 
		 Verification PASSED
		 
		 calc : Time per call (usec):    8.3843998610973358E-002
		 
		****************************************************
				  kernel execution summary: calc
		****************************************************
			Total number of verification cases  :     3
			Number of verification-passed cases :     3
		 
			Average call time (usec):  0.842E-01
			Minimum call time (usec):  0.838E-01
			Maximum call time (usec):  0.847E-01
		****************************************************
